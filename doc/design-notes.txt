Types of page files:
    - Files in memory (page cache)
    - RAM disk files
    - Shared and anonymous memory, backed by swap device

-----
=== Kernel Objects, Capabilities and Memory Allocation ===

Userspace refers to kernel objects and other kernels resources through
descriptors. Each descriptor contains a reference to a kernel resource as well
as a set of permissions on this resource (i.e. it is a capability). Userspace
performs operations on kernel resources through an appropriate descriptor.
Descriptors are specified in the form of an integer, just like Unix file
descriptors.

In addition to being used to perform operations on kernel resources, descriptors
can also be passed to other processes in an IPC message (TBD map vs grant).

Kernel resources can be:
 - Memory management:
    - A block of physical memory (RAM).
    - A page of kernel virtual memory.
    - An array to manage a block of kernel virtual memory (one page).
    - A slab for allocating kernel objects (one page virtual+physical)
 - Capabilities
    - A capability
    - An array of capability slots (one page virtual+physical)
    - An array of pointers to a capability slot array (one page virtual+physical)
    - A small array of pointers to a capability slot array (~64 bytes on a slab)
    - A small second-level array of pointers (~64 bytes on a slab)
    - (TBD) Some sort of L4-style parallel page table structure for memory map
      operations.
 - Address space management:
    - A page table (one page physical only)
    - A page directory (one page physical only)
    - A PDPT (32 bytes on a slab)
 - An IPC endpoint.
 - A thread control block and associated kernel stack and IPC buffer (one page
   virtual+physical)
 - A process control block.
 - (TBD) A process virtual memory region
 - (TBD) An IPC buffer for an interrupt or other microkernel-generated message
 - (TBD) A synchronization kernel object (mutex, semaphore, monitor, etc.)
 - (TBD) An I/O port range

During initialization, the microkernel creates descriptors for all initial
resources (memory, kernel objects, etc.) which it passes to the initial process
(TBD how?).

After initialization is complete, the microkernel never allocates resources
on its own. All resources (e.g. kernel objects) are created by a system call,
and userspace must provide the resources on which it depends (e.g. a memory page).
These allocation system calls can be seen as transforming resources into other
resources, e.g.:

            1 physical memory page + 1 kernel virtual page
                                |
                                | system call
                                v
    Allocation rights for X IPC endpoints (the system call creates a slab)
                                |
                                | system call
                                v
        1 IPC endpoint + Allocation rights for X - 1 IPC endpoints

As in the example above, some descriptors represent allocation right for kernel
objects. These are "counted descriptors", meaning they contain a counter with
the number of objects that can be allocated, and this counter is decremented on
each object allocation. Counted descriptors can be split, and counted
descriptors for identical resources can be merged, both through system calls.

For example, an application that has an allocation right for X > 4 IPC endpoints
can issue a system call to convert it to an allocation right for 4 IPC endpoints
and another allocation right for X - 4 IPC endpoints. It can then pass the
allocation right for the 4 IPC endpoints to another process through an IPC and
keep the rest.

A memory descriptor refers to a block of 2**N pages of physical memory (RAM)
aligned on a 2**N page boundary. A descriptor for such a block of 2**N pages can
be converted (i.e. split) into two blocks of 2**(N-1) pages through a system
call. Similarly, the two resulting descriptors can be converted back (i.e.
merged) into a 2**N-page block. Only the two blocks that were initially part of
a single block (i.e. buddies) can be merged together.

Just like for other resource types, the microkernel creates a list of memory
descriptors from the available physical memory map during initialization and
provides these descriptors to the initial process (TBD how?). No descriptor is
created for any memory allocated to the kernel itself during initialization,
which ensures userspace cannot access kernel memory.

=== Inter-Process Communication (IPC) ===

Main IPC mechanism (summary): Solaris-style doors and filesystem namespace
managed by process manager like QNX.

IPC basic model:
    - Process performs a system call to process manager asking to create an
      IPC object, optionaly specifying a name.
    - Process manager checks:
        - that caller (security domain) is authorized to create an IPC object.
        - that caller is authorized to create a "system" IPC object if that
          was requested.
        - that caller is authorized to create an IPC object with that name.
        - that an IPC object with that name does not already exist.
        - what should be the security type of the IPC object.
    - If all checks out, process manager performs (a) system call(s) to the
      microkernel to create the IPC object, and create an owner reference for
      the caller and a reference for its own use.
    - If applicable, process manager creates a map entry that maps the requested
      name to the new reference, then returns.
    (...)
    - User process performs a system call to the process manager requesting
      a reference to the IPC object.
    - Process manager checks that caller security domain is authorized for that
      object security type.
    - If check OK, process manager creates a reference for the caller and
      returns it.
    - User process uses the new reference to make IPC calls to the IPC object
      owner.
    - When the user process is finished with the IPC object, it closes its
      reference. Reference is automatically closed when the process exits (TBD
      by the process manager or by the microkernel).

IPC function/method numbers:
    0x0+    (A) microkernel system calls
    0x400+  (B) process manager system calls
    0x1000  (C) SYSTEM_BASE
    0x8000  (D) USER_BASE
    -1          INVALID/ERROR

(A) When sent from a process, target is NULL (?), an IPC object or another
    kernel object. Valid target depends on function number.
    
    The microkernel also uses function numbers in this range when delivering
    messages to processes.

(B) When sent from a process other than Process manager, target is (?) NULL (?)
    or an IPC object, maybe other object types. Valid target depends on function
    number. The message is sent to Process manager.
    
    When called from Process manager, Target is an IPC object. The message is
    sent to IPC object owner process.

(C) and (D) Target is an IPC object. Message sent to IPC object owner process
    (only process authorized to wait on this object).

(C) Only function numbers in this range are allowed for "system" IPC objects.
    creating a system IPC object is a priviledged operation (i.e. subject
    to check of security domain).

(D) Only function numbers in this range are allowed for "user" IPC objects.

Message-passing IPC primitives are the only microkernel primitives accessible to
user space. Microkernel system calls are implemented as synchronous messages
sent to the microkernel.

Implementation of message-passing IPC primitives is system-dependent, but uses
the mechanisms typically used for system calls (e.g interrupts and/or sysenter 
or syscall instructions on x86). To ease OS emulation, the following could be
put in place:

 - Per-process (per thread?) configurable interrupt numbers for invoking the
   operating system.
 - A mechanism where, when a thread calls a software interrupt and/or uses the
   syscall/syscall instructions, control is passed to a second thread in the
   same process which is responsible for creating and sending the appropriate
   message (i.e. "sandboxed" threads).
   
Message format:

                +-----------------------+   msgPtr
                |                       |
                |                       |
                |                       |
                |    Message data       |
                |                       |
                |                       |
                |                       |
                +.......................+   msgPtr + msgDataSize
                |       Padding         |
                +-----------------------+
                |     Descriptor 1      |
                |     Descriptor 2      |
                |         ...           |
                |     Descriptor N      |
                +-----------------------+
                |                       |
                |  Reserved for return  |
                |       message         |    
                |                       |
                +-----------------------+   msgPtr + msgTotalSize
                
A send/receive buffer is defined by its starting address (msgPtr) and its size
(msgTotalSize). The same buffer is used for sending the message and receiving
the corresponding response, which means the buffer may need to be bigger than
the message if the response is expected to be bigger.

The first msgDataSize bytes of the buffer contain the message data. The semantic
of this data is agreed upon between the sender and the recipient and is in no
way interpreted by the microkernel (unless the microkernel is the recipient).

Following the message data may be some padding to ensure the platform-dependent
alignment of the start of the descriptors relative to the start of the message
buffer is respected. Following is an array of data records that contain the
following:
 - A single descriptor number or the number of an empty descriptor slot; and
 - An attribute word that contain flags and other information pertain to the
   descriptor.

For each descriptor, either the JINUE_DESC_SEND or JINUE_DESC_RECEIVE attribute
flag must be specified:
 - JINUE_DESC_SEND If this flag is set, the descriptor number must refer to an
   actual descriptor. This descriptor is transferred as part of the message.
 - JINUE_DESC_RECEIVE If this flag is set, the descriptor number must be the
   number of an empty descriptor slot. This descriptor slot will be used to
   receive a single descriptor.

(TBD) is JINUE_DESC_SEND converted to JINUE_DESC_RECEIVE and vice versa when
passed?

Other attributes:
 - (TBD) The type of a received descriptor.
 - JINUE_DESC_VALID Set if a descriptor has actually been received. More
   descriptors can be specified with the JINUE_DESC_RECEIVE flag than will
   actually be received in the expected message or reply.
 - JINUE_DESC_USER1...JINUE_DESC_USERN (N is TBD) Application-specific flags
   that are passed as-is to the message/reply recipient.
 - (TBD) Map vs grant?

Send message arguments (passed in registers):

    +----------------------------------------------------------------+
    |                          msgFunction                           |  arg0
    +----------------------------------------------------------------+
    31                                                               0
    
    +-------------------------------+--------------------------------+
    |           Reserved            |        msgTargetDesc           |  arg1
    +-------------------------------+--------------------------------+
    31                             ? ?                                0

    +----------------------------------------------------------------+
    |                            msgPtr                              |  arg2
    +----------------------------------------------------------------+
    31                                                               0

    +-----------------------+------------------------+---------------+
    |     msgTotalSize      |      msgDataSize       |   msgDescN    |  arg3
    +-----------------------+------------------------+---------------+
    31                    20 19                     8 7              0
   
    
Where:
    
    msgFunction     is the function or system call number.
    msgTargetDesc   is the descriptor for the target of the call (door, thread).
    msgPtr          is address of the start of the message buffer.
    msgTotalSize    is the total size of the buffer, in bytes.
    msgDataSize     is the size of the message data, in bytes.
    msgDescN        is the number of descriptors.

Receive system call arguments (passed in registers):

    +----------------------------------------------------------------+
    |                     msgFunction = RECEIVE                      |  arg0
    +----------------------------------------------------------------+
    31                                                               0
    
    +-------------------------------+--------------------------------+
    |           Reserved            |          msgRecvDesc           |  arg1
    +-------------------------------+--------------------------------+
    31                             ? ?                                0

    +----------------------------------------------------------------+
    |                            msgPtr                              |  arg2
    +----------------------------------------------------------------+
    31                                                               0

    +-----------------------+------------------------+---------------+
    |     msgTotalSize      |           0            |   msgDescN    |  arg3
    +-----------------------+------------------------+---------------+
    31                    20 19                     8 7              0
    
Where:

    msgFunction     is the system call number for RECEIVE.
    msgRecvDesc     is the descriptor for the door from which to receive a
                    message. It must be the owning descriptor for this door.
    msgPtr          is address of the start of the buffer in which to receive
                    the message.
    msgTotalSize    is the total size of the receive buffer, in bytes.
    msgDescN        is the number of descriptors. All descriptor must be
                    specified with the JINUE_DESC_RECEIVE attribute flag.
    

A message can also be received by calling the combined REPLY/RECEIVE system
call. This is described below.

When the RECEIVE or REPLY/RECEIVE system call returns, the arguments provided by
the microkernel are as follow:

    +----------------------------------------------------------------+
    |                        msgFunction (or -1)                     |  arg0
    +----------------------------------------------------------------+
    31                                                               0
    
    +----------------------------------------------------------------+
    |                         msgCookie (or error)                   |  arg1
    +----------------------------------------------------------------+
    31                                                               0

    +----------------------------------------------------------------+
    |                            msgPtr                              |  arg2
    +----------------------------------------------------------------+
    31                                                               0
    
    +-----------------------+------------------------+---------------+
    |     msgTotalSize      |      msgDataSize       |   msgDescN    |  arg3
    +-----------------------+------------------------+---------------+
    31                    20 19                     8 7              0

    
Where:

    msgFunction     is the function number (or -1 if the call to the receive
                    system call fails).
    msgCookie       is the message cookie, as stored by the recipient into the
                    sender's descriptor (or the error number if the call to the
                    receive system call fails).
    msgPtr          is the address of the start of the message buffer (in the
                    recipient's address space).
    msgTotalSize    is the total size of the *sender's* buffer, in bytes. This
                    allows the receiver to know the maximum size allowed for the
                    reply message (and to return an error if it is insufficient).
    msgDataSize     is the size of the message data, in bytes.
    msgDescN        is the number of descriptors.

arg0 and arg3 are copied as-is from the sender's arguments (if the call to the
receive system call is successful).

When replying, the receiver sets the message arguments as follow:

    +----------------------------------------------------------------+
    |              msgFunction = REPLY or REPLY/RECEIVE              |  arg0
    +----------------------------------------------------------------+
    31                                                               0
    
    +----------------------------------------------------------------+
    |                         Reserved (0)                           |  arg1
    +----------------------------------------------------------------+
    31                                                               0

    +----------------------------------------------------------------+
    |                           msgPtr                               |  arg2
    +----------------------------------------------------------------+
    31                                                               0

    +-----------------------+------------------------+---------------+
    |     msgTotalSize      |      msgDataSize       |   msgDescN    |  arg3
    +-----------------------+------------------------+---------------+
    31                    20 19                     8 7              0

Where:

    msgFunction     is the system call number for REPLY or REPLY/RECEIVE
    msgPtr          is the address of the start of the reply message buffer. It
                    may or may not be the buffer where the message being replied
                    to was received. For a combined REPLY/RECEIVE, this is also
                    the buffer in which to receive the next message.
    msgTotalSize    is the total size of the receive buffer, in bytes. This
                    field is only relevant for a combined REPLY/RECEIVE).
    msgDataSize     is the size of the message data, in bytes.
    msgDescN        is the number of descriptors.


When the send primitive returns to the original caller, the arguments provided
by the microkernel are as follow:

    +----------------------------------------------------------------+
    |                            msgRetVal                           |  arg0
    +----------------------------------------------------------------+
    31                                                               0
    
    +----------------------------------------------------------------+
    |                            msgErrno                            |  arg1
    +----------------------------------------------------------------+
    31                                                               0

    +----------------------------------------------------------------+
    |                            Reserved                            |  arg2
    +----------------------------------------------------------------+
    31                                                               0
    
    +-----------------------+------------------------+---------------+
    |       Reserved        |      msgDataSize       |   msgDescN    |  arg3
    +-----------------------+------------------------+---------------+
    31                    20 19                     8 7              0

Where:

    msgRetVal       is the first 32-bit value at the start of the message buffer
                    if msgDataSize is at least 4 bytes, and zero otherwise. By
                    convention, this is typically used to provide a return value.
    msgErrno        is the second 32-bit value from the start of the message
                    buffer if msgDataSize is at least 8 bytes, and zero
                    otherwise. By convention, this is typically used to provide
                    an error code (or zero if the call was successful).
    msgDataSize     is the size of the reply message data, in bytes.
    msgDescN        is the number of descriptors in the reply.

Corner case to consider: What if the receiver calls REPLY with a message too big
for the sender's buffer. Do we fail the call and hope the receiver will provide
another reply? Do we return an error to the sender because of (potentially) an
error on the receiver's part?

To clarify: Is the second word always the error number. The receiver may use the
second word for something else, while the kernel may set an error of its own if
the send fails for some reason. Should we provide a separate REPLY_ERROR (and
REPLY_ERROR/RECEIVE) system call?
